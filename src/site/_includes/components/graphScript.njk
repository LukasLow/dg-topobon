<script src="https://cdn.jsdelivr.net/npm/petite-vue@0.4.1/dist/petite-vue.iife.min.js"></script>
<script>
    PetiteVue.createApp({
    $delimiters: ["${", "}"],
    graphData: null,
    depth: 1,
    graph: null,
    fullGraph: null,
    showFullGraph: false,
    fullScreen: false,

    toggleFullScreen() {
        this.fullScreen = !this.fullScreen;
        this.$nextTick(() => {
            const el = document.querySelector('.graph');
            this.graph.width(el.offsetWidth).height(el.offsetWidth);
            setTimeout(() => {
                this.graph.zoomToFit(5, 75);
            }, 1);
        })
    },

    getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)},

    htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    },

    get fullGraphData() {
        if (this.graphData == null) {
            return null;
        }
        const hiddens = Object.values(this.graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const graphData = {
            links: JSON.parse(JSON.stringify(this.graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(this.graphData.nodes).filter((n) => !n.hide)]
        }
        return graphData;
    },

    renderFullGraph(toggle) {
        this.showFullGraph = true;
        this.$nextTick(() => {
            lucide.createIcons({
                attrs: {
                    class: ["svg-icon"]
                }
            });
            this.fullGraph = this.renderGraph(this.fullGraphData, "full-graph-container", 200);
        })
    },

    renderLocalGraph(data) {
        this.graph = this.renderGraph(data, 'link-graph');
    },

    closefullGraph() {
        if (this.fullGraph) {
            this.fullGraph._destructor();
        }
        this.fullGraph = null;
        this.showFullGraph = false;
    },

    renderGraph(graphData, id, delay) {
        if (graphData == null) {
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        const color = this.getCssVar("--graph-main");
        const mutedColor = this.getCssVar("--graph-muted");

        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return color;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return color;
                } else {
                    return mutedColor;
                }
                
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                if (hoverNode == null) {
                    ctx.fillStyle = color;
                } else {
                    if (node == hoverNode || highlightNodes.has(node.url)) {
                        ctx.fillStyle = color;
                    } else {
                        ctx.fillStyle = mutedColor;
                    }
                }
                 
                ctx.fill();
                
                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }

                const label = this.htmlDecode(node.title)
                const fontSize = 3.5;
                ctx.font = `${fontSize}px Sans-Serif`;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, node.x, node.y + nodeR + 2);
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            if (delay != null && graphData.nodes.length > 4) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay);
            }
        return Graph;
    },

    fetchGraphData() {
        fetch('/graph.json').then(res => res.json()).then(data => {
            this.graphData = data;
        });
    },
    getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    },
    get localGraphData() {
        if (this.graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(this.graphData.nodes));
        let links = JSON.parse(JSON.stringify(this.graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < this.depth; i++) {
            existing, remaining = this.getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        let graphData = {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
        return graphData;
    },
  }).mount();
</script>
